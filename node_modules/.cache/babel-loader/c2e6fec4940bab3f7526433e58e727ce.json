{"ast":null,"code":"import React from 'react';\n\n// vector add\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates velocity\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @param len the length of the delta vector\r\n * @returns velocity\r\n */\n\nfunction calculateVelocity(delta, delta_t, len) {\n  len = len || Math.hypot.apply(Math, delta);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @returns velocities vector\r\n */\n\nfunction calculateVelocities(delta, delta_t) {\n  return delta_t ? delta.map(function (v) {\n    return v / delta_t;\n  }) : Array(delta.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param delta\r\n * @param len\r\n * @returns direction\r\n */\n\nfunction calculateDirection(delta, len) {\n  len = len || Math.hypot.apply(Math, delta) || 1;\n  return delta.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\nfunction calculateAllKinematics(movement, delta, delta_t) {\n  var len = Math.hypot.apply(Math, delta);\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len)\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla\r\n * :https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\nfunction getIntentionalDisplacement(movement, threshold) {\n  var abs = Math.abs(movement);\n  return abs >= threshold ? sign(movement) * threshold : false;\n}\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n  if (constant === 0) return minMax(position, min, max);\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min;\n  }\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max;\n  }\n  return position;\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o) {\n  var i = 0;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  i = o[Symbol.iterator]();\n  return i.next.bind(i);\n}\n\n// blank function\nfunction noop() {} // returns a function that chains all functions given as parameters\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n};\nvar def = {\n  array: function array(value) {\n    return Array.isArray(value) ? value : [value, value];\n  },\n  withDefault: function withDefault(value, defaultIfUndefined) {\n    return value !== void 0 ? value : defaultIfUndefined;\n  }\n};\nfunction matchKeysFromObject(obj, matchingObject) {\n  var o = {};\n  Object.entries(obj).forEach(function (_ref) {\n    var key = _ref[0],\n      value = _ref[1];\n    return (value !== void 0 || key in matchingObject) && (o[key] = value);\n  });\n  return o;\n}\nfunction valueFn(v) {\n  return typeof v === 'function' ? v() : v;\n}\nfunction getInitialState() {\n  // common initial state for all gestures\n  var initialCommon = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }; // initial state for coordinates-based gestures\n\n  var initialCoordinates = {\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  }; // initial state for distance and angle-based gestures (pinch)\n\n  var initialDistanceAngle = {\n    da: [0, 0],\n    vdva: [0, 0],\n    origin: undefined,\n    turns: 0\n  }; // initial state object (used by the gesture controller)\n\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false\n    },\n    drag: _extends(_extends(_extends({}, initialCommon), initialCoordinates), {}, {\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0]\n    }),\n    pinch: _extends(_extends({}, initialCommon), initialDistanceAngle),\n    wheel: _extends(_extends({}, initialCommon), initialCoordinates),\n    move: _extends(_extends({}, initialCommon), initialCoordinates),\n    scroll: _extends(_extends({}, initialCommon), initialCoordinates)\n  };\n}\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var eventName = _ref[0],\n        fn = _ref[1];\n      return el[action](eventName, fn, options);\n    });\n  };\n};\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nvar addListeners = /*#__PURE__*/setListeners(true);\nvar removeListeners = /*#__PURE__*/setListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n    altKey = event.altKey,\n    metaKey = event.metaKey,\n    ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\nfunction getTouchEvents(event) {\n  if ('touches' in event) {\n    var touches = event.touches,\n      changedTouches = event.changedTouches;\n    return touches.length > 0 ? touches : changedTouches;\n  }\n  return null;\n}\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var touchEvents = getTouchEvents(event);\n  var touches = touchEvents && touchEvents.length || 0;\n  var down = touches > 0 || buttons > 0;\n  return _extends({\n    touches: touches,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\nfunction getScrollEventValues(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n    scrollX = _event$currentTarget.scrollX,\n    scrollY = _event$currentTarget.scrollY,\n    scrollLeft = _event$currentTarget.scrollLeft,\n    scrollTop = _event$currentTarget.scrollTop;\n  return {\n    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  };\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\nfunction getWheelEventValues(event) {\n  var deltaX = event.deltaX,\n    deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return {\n    values: [deltaX, deltaY]\n  };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\nfunction getPointerEventValues(event) {\n  var touchEvents = getTouchEvents(event);\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n    clientX = _ref2.clientX,\n    clientY = _ref2.clientY;\n  return {\n    values: [clientX, clientY]\n  };\n}\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\nfunction getWebkitGestureEventValues(event) {\n  return {\n    values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation]\n  };\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var values = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return {\n    values: values,\n    origin: origin\n  };\n}\n\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\nvar Controller = function Controller() {\n  var _this = this;\n  this.state = getInitialState(); // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n  this.clean = function () {\n    _this.resetBindings();\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render).\r\n   * Resets the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n  this.resetBindings = function () {\n    _this.bindings = {};\n    var domTarget = _this.getDomTarget();\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.eventOptions);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Returns the domTarget element and parses a ref if needed.\r\n   */\n\n  this.getDomTarget = function () {\n    var domTarget = _this.config.domTarget;\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window.\r\n   */\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.eventOptions);\n  };\n  /**\r\n   * Commodity function to let recognizers simply remove listeners to config.window.\r\n   */\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.eventOptions);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n  this.addDomTargetListeners = function (target) {\n    /** We iterate on the entries of this.binding for each event, then we chain\r\n     * the array of functions mapped to it and push them to this.domListeners\r\n     */\n    Object.entries(_this.bindings).forEach(function (_ref) {\n      var event = _ref[0],\n        fns = _ref[1];\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(target, _this.domListeners, _this.config.eventOptions);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n  this.addBindings = function (eventNames, fn) {\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      if (_this.bindings[eventName]) _this.bindings[eventName].push(fn);else _this.bindings[eventName] = [fn];\n    });\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with.\r\n   */\n\n  this.getBindings = function () {\n    var bindings = {};\n    var captureString = _this.config.captureString;\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n        fns = _ref2[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      bindings[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return bindings;\n  };\n  this.getBind = function () {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (_this.config.domTarget) {\n      var domTarget = _this.getDomTarget();\n      domTarget && _this.addDomTargetListeners(domTarget);\n      return _this.clean;\n    } // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n\n    return _this.getBindings();\n  };\n};\n\n/**\r\n * @private\r\n *\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param {Partial<InternalHandlers>} handlers\r\n * @param {RecognizerClasses} classes\r\n * @param {InternalConfig} config\r\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useRecognizers(handlers, classes, config, nativeHandlers) {\n  // The gesture controller keeping track of all gesture states\n  var controller = React.useMemo(function () {\n    var current = new Controller();\n    /**\r\n     * The bind function will create gesture recognizers and return the right\r\n     * bind object depending on whether `domTarget` was specified in the config object.\r\n     */\n\n    var bind = function bind() {\n      current.resetBindings();\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      for (var _iterator = _createForOfIteratorHelperLoose(classes), _step; !(_step = _iterator()).done;) {\n        var RecognizerClass = _step.value;\n        new RecognizerClass(current, args).addBindings();\n      } // we also add event bindings for native handlers\n\n      if (controller.nativeRefs) {\n        for (var eventName in controller.nativeRefs) {\n          current.addBindings(eventName,\n          // @ts-ignore we're cheating when it comes to event type :(\n          controller.nativeRefs[eventName]);\n        }\n      }\n      return current.getBind();\n    };\n    return {\n      nativeRefs: nativeHandlers,\n      current: current,\n      bind: bind\n    };\n  }, []); // We reassign the config and handlers to the controller on every render.\n\n  controller.current.config = config;\n  controller.current.handlers = handlers; // We assign nativeHandlers, otherwise they won't be refreshed on the next render.\n\n  controller.nativeRefs = nativeHandlers; // Run controller clean functions on unmount.\n\n  React.useEffect(function () {\n    return controller.current.clean;\n  }, []);\n  return controller.bind;\n}\n\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n *\r\n * @protected\r\n * @abstract\r\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(stateKey, controller, args) {\n    var _this = this;\n    if (args === void 0) {\n      args = [];\n    }\n    this.stateKey = stateKey;\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n      if (ms === void 0) {\n        ms = 140;\n      }\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    }; // Convenience method to add window listeners for a given gesture\n\n    this.addWindowListeners = function (listeners) {\n      _this.controller.addWindowListeners(_this.stateKey, listeners);\n    }; // Convenience method to remove window listeners for a given gesture\n\n    this.removeWindowListeners = function () {\n      _this.controller.removeWindowListeners(_this.stateKey);\n    };\n    /**\r\n     * Returns the reinitialized start state for the gesture.\r\n     * Should be common to all gestures.\r\n     *\r\n     * @param {Vector2} values\r\n     * @param {UseGestureEvent} event\r\n     * @returns - the start state for the gesture\r\n     */\n\n    this.getStartGestureState = function (values, event) {\n      return _extends(_extends({}, getInitialState()[_this.stateKey]), {}, {\n        _active: true,\n        values: values,\n        initial: values,\n        offset: _this.state.offset,\n        lastOffset: _this.state.offset,\n        startTime: event.timeStamp\n      });\n    }; // Runs rubberband on a vector\n\n    this.rubberband = function (vector, rubberband) {\n      var bounds = _this.config.bounds;\n      /**\r\n       * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\r\n       */\n\n      return vector.map(function (v, i) {\n        return rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i]);\n      });\n    };\n    /**\r\n     * Fires the gesture handler\r\n     *\r\n     * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\r\n     */\n\n    this.fireGestureHandler = function (forceFlag) {\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n          _this.clean();\n        }\n        return null;\n      } // If the gesture has no intentional dimension, don't do fire the handler.\n\n      var _this$state$_intentio = _this.state._intentional,\n        intentionalX = _this$state$_intentio[0],\n        intentionalY = _this$state$_intentio[1];\n      if (!forceFlag && intentionalX === false && intentionalY === false) return null;\n      var _this$state = _this.state,\n        _active = _this$state._active,\n        active = _this$state.active;\n      _this.state.active = _active;\n      _this.state.first = _active && !active; // `first` is true when the gesture becomes active\n\n      _this.state.last = active && !_active; // `last` is true when the gesture becomes inactive\n\n      _this.controller.state.shared[_this.ingKey] = _active; // Sets dragging, pinching, etc. to the gesture active state\n\n      var state = _extends(_extends(_extends({}, _this.controller.state.shared), _this.state), _this.mapStateValues(_this.state)); // @ts-ignore\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n\n      if (!_active) _this.clean();\n      return state;\n    };\n  } // Returns the gesture config\n\n  var _proto = Recognizer.prototype;\n\n  // Conveninence method to update the shared state\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Conveninence method to update the gesture state\n  ;\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns a generic, common payload for all gestures from an event.\r\n   *\r\n   * @param {UseGestureEvent} event\r\n   * @param {boolean} [isStartEvent]\r\n   * @returns - the generic gesture payload\r\n   */;\n  _proto.getGenericPayload = function getGenericPayload(event, isStartEvent) {\n    var timeStamp = event.timeStamp,\n      type = event.type;\n    var _this$state2 = this.state,\n      values = _this$state2.values,\n      startTime = _this$state2.startTime;\n    return {\n      _lastEventType: type,\n      event: event,\n      timeStamp: timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime,\n      args: this.args,\n      previous: values\n    };\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */;\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, _state) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */;\n  _proto.getMovement = function getMovement(values, state) {\n    if (state === void 0) {\n      state = this.state;\n    }\n    var _this$config = this.config,\n      initial = _this$config.initial,\n      threshold = _this$config.threshold,\n      rubberband = _this$config.rubberband;\n    var t0 = threshold[0],\n      t1 = threshold[1];\n    var _state2 = state,\n      _initial = _state2._initial,\n      _active = _state2._active,\n      intentional = _state2._intentional,\n      lastOffset = _state2.lastOffset,\n      prevMovement = _state2.movement;\n    var i0 = intentional[0],\n      i1 = intentional[1];\n    var _this$getInternalMove = this.getInternalMovement(values, state),\n      _m0 = _this$getInternalMove[0],\n      _m1 = _this$getInternalMove[1];\n    /**\r\n     * For both dimensions of the gesture, check its intentionality on each frame.\r\n     */\n\n    if (i0 === false) {\n      i0 = getIntentionalDisplacement(_m0, t0);\n    }\n    if (i1 === false) {\n      i1 = getIntentionalDisplacement(_m1, t1);\n    } // Get gesture specific state properties based on intentionality and movement.\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state);\n    var _intentional = intentionalityCheck._intentional,\n      _blocked = intentionalityCheck._blocked;\n    var _i0 = _intentional[0],\n      _i1 = _intentional[1];\n    var _movement = [_m0, _m1];\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0];\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1];\n    /**\r\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\r\n     * stop right there.\r\n     */\n\n    if (_blocked) return _extends(_extends({}, intentionalityCheck), {}, {\n      _movement: _movement,\n      delta: [0, 0]\n    });\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_i0 !== false ? _m0 - _i0 : valueFn(initial)[0], _i1 !== false ? _m1 - _i1 : valueFn(initial)[1]];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n    movement = this.rubberband(addV(movement, _initial), _rubberband); // rubberbanded movement\n\n    return _extends(_extends({}, intentionalityCheck), {}, {\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      offset: this.rubberband(offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n  _proto.clean = function clean() {\n    this.clearTimeout();\n    this.removeWindowListeners();\n  };\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }]);\n  return Recognizer;\n}();\n\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n * @abstract\r\n * @class CoordinatesRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n  var _proto = CoordinatesRecognizer.prototype;\n\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   *\r\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\r\n   * @param {Vector2} _movement\r\n   * @param {PartialGestureState<T>} state\r\n   */;\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, state) {\n    var _intentional2 = _intentional,\n      _ix = _intentional2[0],\n      _iy = _intentional2[1];\n    var intentionalMovement = _ix !== false || _iy !== false;\n    var axis = state.axis;\n    var _blocked = false; // If the movement is intentional, we can compute axis.\n\n    if (intentionalMovement) {\n      var _movement$map = _movement.map(Math.abs),\n        absX = _movement$map[0],\n        absY = _movement$map[1];\n      var _this$config = this.config,\n        configAxis = _this$config.axis,\n        lockDirection = _this$config.lockDirection; // We make sure we only set axis value if it hadn't been detected before.\n\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true;else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            var lockedIndex = axis === 'x' ? 1 : 0;\n            _intentional[lockedIndex] = false;\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false];\n        }\n      }\n    }\n    return {\n      _intentional: _intentional,\n      _blocked: _blocked,\n      axis: axis\n    };\n  };\n  _proto.getKinematics = function getKinematics(values, event) {\n    var timeStamp = this.state.timeStamp;\n    var movementDetection = this.getMovement(values, this.state);\n    var _blocked = movementDetection._blocked,\n      delta = movementDetection.delta,\n      movement = movementDetection.movement;\n    if (_blocked) return movementDetection;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends(_extends({\n      values: values,\n      delta: delta\n    }, movementDetection), kinematics);\n  };\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n  return CoordinatesRecognizer;\n}(Recognizer);\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\nvar FILTER_REPEATED_EVENTS_DELAY = 200;\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n  function DragRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n    _this.ingKey = 'dragging';\n    _this.wasTouch = false;\n    _this.isEventTypeTouch = function (type) {\n      return !!type && type.indexOf('touch') === 0;\n    };\n    _this.dragShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n        touches = _getGenericEventData.touches;\n      var _lastEventType = _this.state._lastEventType;\n      /**\r\n       * This tries to filter out mouse events triggered by touch screens\r\n       * */\n      // If the previous gesture was touch-based, and the current one is mouse based,\n      // this means that we might be dealing with mouse simulated events if they're close to\n      // each other. We're only doing this check when we're not using pointer events.\n\n      if (!_this.controller.config.pointer && _this.isEventTypeTouch(_lastEventType) && !_this.isEventTypeTouch(event.type)) {\n        var delay = Math.abs(event.timeStamp - _this.state.startTime);\n        if (delay < FILTER_REPEATED_EVENTS_DELAY) return false;\n      }\n      return _this.enabled && touches < 2;\n    };\n    _this.setPointers = function (event) {\n      var currentTarget = event.currentTarget,\n        pointerId = event.pointerId;\n      if (currentTarget) currentTarget.setPointerCapture(pointerId);\n      _this.updateGestureState({\n        currentTarget: currentTarget,\n        pointerId: pointerId\n      });\n    };\n    _this.removePointers = function () {\n      var _this$state = _this.state,\n        currentTarget = _this$state.currentTarget,\n        pointerId = _this$state.pointerId;\n      if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId);\n    };\n    _this.setListeners = function (isTouch) {\n      _this.removeWindowListeners();\n      var dragListeners = isTouch ? [['touchmove', _this.onDragChange], ['touchend', _this.onDragEnd], ['touchcancel', _this.onDragEnd]] : [['mousemove', _this.onDragChange], ['mouseup', _this.onDragEnd]];\n      _this.addWindowListeners(dragListeners);\n    };\n    _this.onDragStart = function (event) {\n      if (!_this.dragShouldStart(event)) return; // if pointers events\n\n      if (_this.controller.config.pointer) _this.setPointers(event);else _this.setListeners(_this.isEventTypeTouch(event.type));\n      if (_this.config.delay > 0) {\n        _this.state._delayedEvent = true;\n        if (typeof event.persist === 'function') event.persist();\n        _this.setTimeout(function () {\n          return _this.startDrag(event);\n        }, _this.config.delay);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n    _this.onDragChange = function (event) {\n      var canceled = _this.state.canceled;\n      if (canceled) return;\n      if (!_this.state._active) {\n        if (_this.state._delayedEvent) {\n          _this.clearTimeout();\n          _this.startDrag(event);\n        }\n        return;\n      }\n      var genericEventData = getGenericEventData(event);\n      if (!genericEventData.down) {\n        _this.onDragEnd(event);\n        return;\n      }\n      _this.updateSharedState(genericEventData);\n      var _getPointerEventValue = getPointerEventValues(event),\n        values = _getPointerEventValue.values;\n      var kinematics = _this.getKinematics(values, event);\n      var _isTap = _this.state._isTap;\n      if (_isTap && calculateDistance(kinematics._movement) >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        _isTap: _isTap,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onDragEnd = function (event) {\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n      var _this$state2 = _this.state,\n        _isTap = _this$state2._isTap,\n        values = _this$state2.values,\n        _this$state2$velociti = _this$state2.velocities,\n        vx = _this$state2$velociti[0],\n        vy = _this$state2$velociti[1],\n        _this$state2$movement = _this$state2.movement,\n        mx = _this$state2$movement[0],\n        my = _this$state2$movement[1],\n        _this$state2$_intenti = _this$state2._intentional,\n        ix = _this$state2$_intenti[0],\n        iy = _this$state2$_intenti[1];\n      var endState = _extends(_extends({}, _this.getGenericPayload(event)), _this.getMovement(values));\n      var elapsedTime = endState.elapsedTime;\n      var _this$config = _this.config,\n        _this$config$swipeVel = _this$config.swipeVelocity,\n        svx = _this$config$swipeVel[0],\n        svy = _this$config$swipeVel[1],\n        _this$config$swipeDis = _this$config.swipeDistance,\n        sx = _this$config$swipeDis[0],\n        sy = _this$config$swipeDis[1];\n      var swipe = [0, 0];\n      if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n      _this.updateGestureState(_extends(_extends({\n        event: event\n      }, endState), {}, {\n        tap: _isTap,\n        swipe: swipe\n      }));\n      _this.fireGestureHandler(_this.config.filterTaps && _this.state._isTap);\n    };\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n      _this.state._delayedEvent = false;\n      if (_this.controller.config.pointer) _this.removePointers();\n    };\n    _this.onCancel = function () {\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    return _this;\n  }\n  var _proto = DragRecognizer.prototype;\n  _proto.startDrag = function startDrag(event) {\n    var _this2 = this;\n    var _getPointerEventValue2 = getPointerEventValues(event),\n      values = _getPointerEventValue2.values;\n    this.updateSharedState(getGenericEventData(event));\n    var startState = _extends(_extends({}, this.getStartGestureState(values, event)), this.getGenericPayload(event, true));\n    this.updateGestureState(_extends(_extends(_extends({}, startState), this.getMovement(values, startState)), {}, {\n      cancel: function cancel() {\n        return _this2.onCancel();\n      }\n    }));\n    this.fireGestureHandler();\n  };\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart);\n      this.controller.addBindings('onPointerMove', this.onDragChange);\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd);\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart);\n    }\n  };\n  return DragRecognizer;\n}(CoordinatesRecognizer);\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar defaultWindow = typeof window !== 'undefined' ? window : undefined;\nvar defaultCoordinatesOptions = {\n  lockDirection: false,\n  axis: undefined,\n  bounds: undefined\n};\n/**\r\n * @private\r\n *\r\n * Returns the internal generic option object.\r\n *\r\n * @param {Partial<GenericOptions>} [config={}]\r\n * @returns {InternalGenericOptions}\r\n */\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _config = config,\n    _config$eventOptions = _config.eventOptions;\n  _config$eventOptions = _config$eventOptions === void 0 ? {} : _config$eventOptions;\n  var _config$eventOptions$ = _config$eventOptions.passive,\n    passive = _config$eventOptions$ === void 0 ? true : _config$eventOptions$,\n    _config$eventOptions$2 = _config$eventOptions.capture,\n    capture = _config$eventOptions$2 === void 0 ? false : _config$eventOptions$2,\n    _config$eventOptions$3 = _config$eventOptions.pointer,\n    pointer = _config$eventOptions$3 === void 0 ? false : _config$eventOptions$3,\n    _config$window = _config.window,\n    window = _config$window === void 0 ? defaultWindow : _config$window,\n    _config$domTarget = _config.domTarget,\n    domTarget = _config$domTarget === void 0 ? undefined : _config$domTarget,\n    _config$enabled = _config.enabled,\n    enabled = _config$enabled === void 0 ? true : _config$enabled,\n    restConfig = _objectWithoutPropertiesLoose(_config, [\"eventOptions\", \"window\", \"domTarget\", \"enabled\"]);\n  return _extends(_extends({}, restConfig), {}, {\n    enabled: enabled,\n    domTarget: domTarget,\n    window: window,\n    // passive is always true if there's no domTarget\n    eventOptions: {\n      passive: !domTarget || !!passive,\n      capture: !!capture\n    },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer\n  });\n}\nfunction getInternalGestureOptions(gestureConfig) {\n  var _gestureConfig$thresh = gestureConfig.threshold,\n    threshold = _gestureConfig$thresh === void 0 ? undefined : _gestureConfig$thresh,\n    _gestureConfig$rubber = gestureConfig.rubberband,\n    rubberband = _gestureConfig$rubber === void 0 ? 0 : _gestureConfig$rubber,\n    _gestureConfig$enable = gestureConfig.enabled,\n    enabled = _gestureConfig$enable === void 0 ? true : _gestureConfig$enable,\n    _gestureConfig$initia = gestureConfig.initial,\n    initial = _gestureConfig$initia === void 0 ? [0, 0] : _gestureConfig$initia;\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0;\n  if (threshold === void 0) threshold = 0;\n  return {\n    enabled: enabled,\n    initial: initial,\n    threshold: def.array(threshold),\n    rubberband: def.array(rubberband)\n  };\n}\nfunction getInternalCoordinatesOptions(coordinatesConfig) {\n  if (coordinatesConfig === void 0) {\n    coordinatesConfig = {};\n  }\n  var _coordinatesConfig = coordinatesConfig,\n    axis = _coordinatesConfig.axis,\n    lockDirection = _coordinatesConfig.lockDirection,\n    _coordinatesConfig$bo = _coordinatesConfig.bounds,\n    bounds = _coordinatesConfig$bo === void 0 ? {} : _coordinatesConfig$bo,\n    internalOptions = _objectWithoutPropertiesLoose(_coordinatesConfig, [\"axis\", \"lockDirection\", \"bounds\"]);\n  var boundsArray = [[def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)], [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)]];\n  return _extends(_extends(_extends(_extends({}, getInternalGestureOptions(internalOptions)), defaultCoordinatesOptions), matchKeysFromObject({\n    axis: axis,\n    lockDirection: lockDirection\n  }, coordinatesConfig)), {}, {\n    bounds: boundsArray\n  });\n}\nfunction getInternalDistanceAngleOptions(distanceAngleConfig) {\n  if (distanceAngleConfig === void 0) {\n    distanceAngleConfig = {};\n  }\n  var _distanceAngleConfig = distanceAngleConfig,\n    _distanceAngleConfig$ = _distanceAngleConfig.distanceBounds,\n    distanceBounds = _distanceAngleConfig$ === void 0 ? {} : _distanceAngleConfig$,\n    _distanceAngleConfig$2 = _distanceAngleConfig.angleBounds,\n    angleBounds = _distanceAngleConfig$2 === void 0 ? {} : _distanceAngleConfig$2,\n    internalOptions = _objectWithoutPropertiesLoose(_distanceAngleConfig, [\"distanceBounds\", \"angleBounds\"]);\n  var boundsArray = [[def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)], [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)]];\n  return _extends(_extends({}, getInternalGestureOptions(internalOptions)), {}, {\n    bounds: boundsArray\n  });\n}\nfunction getInternalDragOptions(dragConfig) {\n  if (dragConfig === void 0) {\n    dragConfig = {};\n  }\n  var _dragConfig = dragConfig,\n    enabled = _dragConfig.enabled,\n    threshold = _dragConfig.threshold,\n    bounds = _dragConfig.bounds,\n    rubberband = _dragConfig.rubberband,\n    initial = _dragConfig.initial,\n    dragOptions = _objectWithoutPropertiesLoose(_dragConfig, [\"enabled\", \"threshold\", \"bounds\", \"rubberband\", \"initial\"]);\n  var _dragOptions$swipeVel = dragOptions.swipeVelocity,\n    swipeVelocity = _dragOptions$swipeVel === void 0 ? DEFAULT_SWIPE_VELOCITY : _dragOptions$swipeVel,\n    _dragOptions$swipeDis = dragOptions.swipeDistance,\n    swipeDistance = _dragOptions$swipeDis === void 0 ? DEFAULT_SWIPE_DISTANCE : _dragOptions$swipeDis,\n    _dragOptions$delay = dragOptions.delay,\n    delay = _dragOptions$delay === void 0 ? false : _dragOptions$delay,\n    _dragOptions$filterTa = dragOptions.filterTaps,\n    filterTaps = _dragOptions$filterTa === void 0 ? false : _dragOptions$filterTa,\n    axis = dragOptions.axis,\n    lockDirection = dragOptions.lockDirection;\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0);\n  } else {\n    filterTaps = true;\n  }\n  var internalCoordinatesOptions = getInternalCoordinatesOptions(matchKeysFromObject({\n    enabled: enabled,\n    threshold: threshold,\n    bounds: bounds,\n    rubberband: rubberband,\n    axis: axis,\n    lockDirection: lockDirection,\n    initial: initial\n  }, dragConfig));\n  return _extends(_extends({}, internalCoordinatesOptions), {}, {\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity),\n    swipeDistance: def.array(swipeDistance),\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0\n  });\n}\n\n/**\r\n * @public\r\n *\r\n * Drag hook.\r\n *\r\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _config = config,\n    domTarget = _config.domTarget,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    drag = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    drag: getInternalDragOptions(drag)\n  });\n  return useRecognizers({\n    drag: handler\n  }, [DragRecognizer], mergedConfig);\n}\n\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n * @abstract\r\n * @class DistanceAngleRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n  var _proto = DistanceAngleRecognizer.prototype;\n\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n  _proto.getInternalMovement = function getInternalMovement(_ref, state) {\n    var d = _ref[0],\n      a = _ref[1];\n    var da = state.values,\n      turns = state.turns,\n      initial = state.initial; // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n\n    a = a !== void 0 ? a : da[1];\n    var delta_a = a - da[1];\n    /**\r\n     * The angle value might jump from 179deg to -179deg when we actually want to\r\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\r\n     */\n\n    var newTurns = Math.abs(delta_a) > 270 ? turns + sign(delta_a) : turns; // we update the angle difference to its corrected value\n\n    var movement_d = d - initial[0];\n    var movement_a = a - 360 * newTurns - initial[1];\n    return [movement_d, movement_a];\n  };\n  _proto.getKinematics = function getKinematics(values, event) {\n    var _this$state = this.state,\n      timeStamp = _this$state.timeStamp,\n      initial = _this$state.initial;\n    var movementDetection = this.getMovement(values, this.state);\n    var delta = movementDetection.delta,\n      movement = movementDetection.movement;\n    var turns = (values[1] - movement[1] - initial[1]) / 360;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends(_extends({\n      values: values,\n      delta: delta,\n      turns: turns\n    }, movementDetection), kinematics);\n  };\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n  return DistanceAngleRecognizer;\n}(Recognizer);\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n  function PinchRecognizer(controller, args) {\n    var _this;\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.ingKey = 'pinching';\n    _this.pinchShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n        touches = _getGenericEventData.touches;\n      return _this.enabled && touches === 2;\n    };\n    _this.onPinchStart = function (event) {\n      if (!_this.pinchShouldStart(event)) return;\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n        values = _getTwoTouchesEventDa.values,\n        origin = _getTwoTouchesEventDa.origin;\n      _this.updateSharedState(getGenericEventData(event));\n      var startState = _extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true));\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), _this.getMovement(values, startState)), {}, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n        canceled = _this$state.canceled,\n        timeStamp = _this$state.timeStamp,\n        _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n      if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return;\n      _this.updateSharedState(genericEventData);\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n        values = _getTwoTouchesEventDa2.values,\n        origin = _getTwoTouchesEventDa2.origin;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onPinchEnd = function (event) {\n      if (!_this.state.active) return;\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n      _this.updateGestureState(_extends(_extends({\n        event: event\n      }, _this.getGenericPayload(event)), _this.getMovement(_this.state.values)));\n      _this.fireGestureHandler();\n    };\n    _this.onCancel = function () {\n      _this.state._active = false;\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault();\n      var _getWebkitGestureEven = getWebkitGestureEventValues(event),\n        values = _getWebkitGestureEven.values;\n      _this.updateSharedState(getGenericEventData(event));\n      var startState = _extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true));\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), _this.getMovement(values, startState)), {}, {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n        canceled = _this$state2.canceled,\n        _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var _getWebkitGestureEven2 = getWebkitGestureEventValues(event),\n        values = _getWebkitGestureEven2.values;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      if (!_this.state.active) return;\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n      _this.updateGestureState(_extends(_extends({\n        event: event\n      }, _this.getGenericPayload(event)), _this.getMovement(_this.state.values)));\n      _this.fireGestureHandler();\n    };\n    _this.updateTouchData = function (event) {\n      if (!_this.enabled || event.touches.length !== 2 || !_this.state._active) return;\n      var _getTwoTouchesEventDa3 = getTwoTouchesEventData(event),\n        origin = _getTwoTouchesEventDa3.origin;\n      _this.state.origin = origin;\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event),\n        _getWheelEventValues$ = _getWheelEventValues.values,\n        delta_d = _getWheelEventValues$[1];\n      var _this$state$values = _this.state.values,\n        prev_d = _this$state$values[0],\n        prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n      _this.clearTimeout();\n      _this.setTimeout(_this.onWheelEnd);\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n        values = _this$getWheelValuesF.values,\n        delta = _this$getWheelValuesF.delta,\n        origin = _this$getWheelValuesF.origin;\n      if (!_this.controller.config.eventOptions.passive) {\n        event.preventDefault();\n      } else if (process.env.NODE_ENV === 'development') {\n        console.warn('To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.');\n      }\n      _this.updateSharedState(getGenericEventData(event));\n      var startState = _extends(_extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true)), {}, {\n        initial: _this.state.values\n      });\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), _this.getMovement(values, startState)), {}, {\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n        values = _this$getWheelValuesF2.values,\n        origin = _this$getWheelValuesF2.origin,\n        delta = _this$getWheelValuesF2.delta;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        origin: origin,\n        delta: delta\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = PinchRecognizer.prototype;\n  _proto.addBindings = function addBindings() {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart);\n      this.controller.addBindings('onGestureChange', this.onGestureChange);\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd);\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData);\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart);\n      this.controller.addBindings('onTouchMove', this.onPinchChange);\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd);\n      this.controller.addBindings('onWheel', this.onWheel);\n    }\n  };\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n\n/**\r\n * @public\r\n *\r\n * Pinch hook.\r\n *\r\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _config = config,\n    domTarget = _config.domTarget,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    pinch = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    pinch: getInternalDistanceAngleOptions(pinch)\n  });\n  return useRecognizers({\n    pinch: handler\n  }, [PinchRecognizer], mergedConfig);\n}\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n  function WheelRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n    _this.ingKey = 'wheeling';\n    _this.debounced = true;\n    _this.wheelShouldRun = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return false;\n      return _this.enabled;\n    };\n    _this.getValuesFromEvent = function (event) {\n      var prevValues = _this.state.values;\n      var _getWheelEventValues = getWheelEventValues(event),\n        values = _getWheelEventValues.values;\n      return {\n        values: addV(values, prevValues)\n      };\n    };\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n      _this.clearTimeout();\n      _this.setTimeout(_this.onWheelEnd);\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n    _this.onWheelStart = function (event) {\n      var _this$getValuesFromEv = _this.getValuesFromEvent(event),\n        values = _this$getValuesFromEv.values;\n      _this.updateSharedState(getGenericEventData(event));\n      var startState = _extends(_extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true)), {}, {\n        initial: _this.state.values\n      });\n      var movementDetection = _this.getMovement(values, startState);\n      var delta = movementDetection.delta;\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), movementDetection), {}, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var _this$getValuesFromEv2 = _this.getValuesFromEvent(event),\n        values = _this$getValuesFromEv2.values;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends(_extends({}, _this.getGenericPayload(event)), kinematics));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n      _this.updateGestureState(_extends(_extends({}, _this.getMovement(_this.state.values)), {}, {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = WheelRecognizer.prototype;\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onWheel', this.onWheel);\n  };\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * @public\r\n *\r\n * Wheel hook.\r\n *\r\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _config = config,\n    domTarget = _config.domTarget,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    wheel = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    wheel: getInternalCoordinatesOptions(wheel)\n  });\n  return useRecognizers({\n    wheel: handler\n  }, [WheelRecognizer], mergedConfig);\n}\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n  function MoveRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n    _this.ingKey = 'moving';\n    _this.debounced = true;\n    _this.moveShouldRun = function () {\n      return _this.enabled;\n    };\n    _this.onMove = function (event) {\n      if (!_this.moveShouldRun()) return;\n      _this.clearTimeout();\n      _this.setTimeout(_this.onMoveEnd);\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n    _this.onMoveStart = function (event) {\n      var _getPointerEventValue = getPointerEventValues(event),\n        values = _getPointerEventValue.values;\n      _this.updateSharedState(getGenericEventData(event));\n      var startState = _extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true));\n      _this.updateGestureState(_extends(_extends({}, startState), _this.getMovement(values, startState)));\n      _this.fireGestureHandler();\n    };\n    _this.onMoveChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var _getPointerEventValue2 = getPointerEventValues(event),\n        values = _getPointerEventValue2.values;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends(_extends({}, _this.getGenericPayload(event)), kinematics));\n      _this.fireGestureHandler();\n    };\n    _this.onMoveEnd = function () {\n      _this.state._active = false;\n      _this.updateGestureState(_extends(_extends({}, _this.getMovement(_this.state.values)), {}, {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue3 = getPointerEventValues(event),\n          values = _getPointerEventValue3.values;\n        var state = _extends(_extends(_extends(_extends({}, _this.controller.state.shared), _this.state), _this.getGenericPayload(event, true)), {}, {\n          values: values,\n          active: true,\n          hovering: true\n        });\n        _this.controller.handlers.hover(_extends(_extends({}, state), _this.mapStateValues(state)));\n      }\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue4 = getPointerEventValues(event),\n          values = _getPointerEventValue4.values;\n        var state = _extends(_extends(_extends(_extends({}, _this.controller.state.shared), _this.state), _this.getGenericPayload(event)), {}, {\n          values: values,\n          active: false\n        });\n        _this.controller.handlers.hover(_extends(_extends({}, state), _this.mapStateValues(state)));\n      }\n    };\n    return _this;\n  }\n  var _proto = MoveRecognizer.prototype;\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove);\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter);\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave);\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove);\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter);\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave);\n      }\n    }\n  };\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * @public\r\n *\r\n * Move hook.\r\n *\r\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _config = config,\n    domTarget = _config.domTarget,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    move = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    move: getInternalCoordinatesOptions(move)\n  });\n  return useRecognizers({\n    move: handler\n  }, [MoveRecognizer], mergedConfig);\n}\n\n/**\r\n * @public\r\n *\r\n * Hover hook.\r\n *\r\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _config = config,\n    domTarget = _config.domTarget,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    hover = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    hover: _extends({\n      enabled: true\n    }, hover)\n  });\n  return useRecognizers({\n    hover: handler\n  }, [MoveRecognizer], mergedConfig);\n}\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n  function ScrollRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n    _this.ingKey = 'scrolling';\n    _this.debounced = true;\n    _this.scrollShouldRun = function () {\n      return _this.enabled;\n    };\n    _this.onScroll = function (event) {\n      if (!_this.scrollShouldRun()) return;\n      _this.clearTimeout();\n      _this.setTimeout(_this.onScrollEnd);\n      if (!_this.state._active) _this.onScrollStart(event);else _this.onScrollChange(event);\n    };\n    _this.onScrollStart = function (event) {\n      var _getScrollEventValues = getScrollEventValues(event),\n        values = _getScrollEventValues.values;\n      _this.updateSharedState(getGenericEventData(event));\n      var startState = _extends(_extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true)), {}, {\n        initial: _this.state.values\n      });\n      var movementDetection = _this.getMovement(values, startState);\n      var delta = movementDetection.delta;\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), movementDetection), {}, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onScrollChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var _getScrollEventValues2 = getScrollEventValues(event),\n        values = _getScrollEventValues2.values;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends(_extends({}, _this.getGenericPayload(event)), kinematics));\n      _this.fireGestureHandler();\n    };\n    _this.onScrollEnd = function () {\n      _this.state._active = false;\n      _this.updateGestureState(_extends(_extends({}, _this.getMovement(_this.state.values)), {}, {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = ScrollRecognizer.prototype;\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onScroll', this.onScroll);\n  };\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * @public\r\n *\r\n * Scroll hook.\r\n *\r\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _config = config,\n    domTarget = _config.domTarget,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    scroll = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    scroll: getInternalCoordinatesOptions(scroll)\n  });\n  return useRecognizers({\n    scroll: handler\n  }, [ScrollRecognizer], mergedConfig);\n}\n\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useGesture(handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  /**\r\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\r\n   * actions will include 'onDrag' and 'onMove.\r\n   */\n  var _React$useState = React.useState(function () {\n      return new Set(Object.keys(handlers).map(function (k) {\n        return k.replace(/End|Start/, '');\n      }));\n    }),\n    actions = _React$useState[0];\n  /**\r\n   * Here we compute the derived internal config based on the provided config object.\r\n   * We decompose the config into its generic and gesture options and compute each.\r\n   * TODO: this is currently done on every render!\r\n   */\n\n  var _config = config,\n    drag = _config.drag,\n    wheel = _config.wheel,\n    move = _config.move,\n    scroll = _config.scroll,\n    pinch = _config.pinch,\n    hover = _config.hover,\n    restConfig = _objectWithoutPropertiesLoose(_config, [\"drag\", \"wheel\", \"move\", \"scroll\", \"pinch\", \"hover\"]);\n  var mergedConfig = getInternalGenericOptions(restConfig);\n  var classes = [];\n  var internalHandlers = {}; // will hold reference to native handlers such as onClick, onMouseDown, etc.\n\n  var _nativeHandlers = _extends({}, handlers);\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer);\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers);\n    mergedConfig.drag = getInternalDragOptions(drag);\n  }\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer);\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers);\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  }\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer);\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers);\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  }\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer);\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers);\n    mergedConfig.move = getInternalCoordinatesOptions(move);\n  }\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer);\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers);\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  }\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer);\n    internalHandlers.hover = handlers.onHover;\n    mergedConfig.hover = _extends({\n      enabled: true\n    }, hover);\n    delete _nativeHandlers.onHover;\n  }\n  return useRecognizers(internalHandlers, classes, mergedConfig, _nativeHandlers);\n}\n/**\r\n * @private\r\n *\r\n * This utility function will integrate start and end handlers into the regular\r\n * handler function by using first and last conditions.\r\n *\r\n * @param {UserHandlersPartial} handlers - the handlers function object\r\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\r\n * @returns\r\n */\n\nfunction includeStartEndHandlers(handlers, handlerKey, _nativeHandlers) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n  delete _nativeHandlers[handlerKey];\n  delete _nativeHandlers[startKey];\n  delete _nativeHandlers[endKey];\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  return fn;\n}\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"names":["addV","v1","v2","map","v","i","subV","calculateVelocity","delta","delta_t","len","Math","hypot","apply","calculateVelocities","Array","length","fill","calculateDistance","movement","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","sign","x","Number","getIntentionalDisplacement","threshold","abs","minMax","value","min","max","rubberband2","constant","pow","rubberband","dimension","Infinity","rubberbandIfOutOfBounds","position","noop","chainFns","_len","arguments","fns","_key","_len2","args","_key2","forEach","fn","def","array","isArray","withDefault","defaultIfUndefined","matchKeysFromObject","obj","matchingObject","o","Object","entries","_ref","key","valueFn","getInitialState","initialCommon","_active","_blocked","_intentional","_movement","_initial","_lastEventType","undefined","event","values","offset","lastOffset","initial","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","initialCoordinates","axis","xy","vxvy","initialDistanceAngle","da","vdva","origin","turns","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","drag","_extends","_isTap","_delayedEvent","tap","swipe","pinch","wheel","move","scroll","setListeners","add","el","listeners","options","action","eventName","supportsGestureEvents","GestureEvent","e","addListeners","removeListeners","getModifierKeys","getTouchEvents","changedTouches","getGenericEventData","touchEvents","getScrollEventValues","currentTarget","scrollX","_event$currentTarget","scrollY","scrollLeft","scrollTop","getWheelEventValues","deltaX","deltaY","getPointerEventValues","clientX","_ref2","clientY","WEBKIT_DISTANCE_SCALE_FACTOR","getWebkitGestureEventValues","scale","rotation","getTwoTouchesEventData","dx","dy","atan2","PI","Controller","state","timeouts","domListeners","windowListeners","bindings","clean","_this","resetBindings","clearTimeout","keys","stateKey","removeWindowListeners","domTarget","getDomTarget","config","eventOptions","current","addWindowListeners","window","addDomTargetListeners","target","push","substr","toLowerCase","addBindings","eventNames","eventNamesArray","getBindings","captureString","fnsArray","getBind","useRecognizers","handlers","classes","nativeHandlers","controller","React","useMemo","bind","_iterator","_createForOfIteratorHelperLoose","_step","done","RecognizerClass","nativeRefs","useEffect","Recognizer","debounced","setTimeout","callback","ms","_window","concat","getStartGestureState","vector","bounds","fireGestureHandler","forceFlag","intentionalX","_this$state$_intentio","intentionalY","_this$state","ingKey","mapStateValues","newMemo","handler","updateSharedState","sharedState","assign","updateGestureState","gestureState","getGenericPayload","isStartEvent","type","_this$state2","checkIntentionality","_state","getMovement","_this$config","t0","t1","_state2","intentional","prevMovement","i0","i1","getInternalMovement","_m0","_this$getInternalMove","_m1","intentionalityCheck","_i0","_i1","_rubberband","enabled","CoordinatesRecognizer","_Recognizer","_ix","_intentional2","_iy","intentionalMovement","_movement$map","absX","absY","configAxis","lockDirection","lockedIndex","getKinematics","movementDetection","kinematics","TAP_DISTANCE_THRESHOLD","SWIPE_MAX_ELAPSED_TIME","FILTER_REPEATED_EVENTS_DELAY","DragRecognizer","_CoordinatesRecognize","call","wasTouch","isEventTypeTouch","indexOf","dragShouldStart","_getGenericEventData","pointer","delay","setPointers","pointerId","setPointerCapture","removePointers","releasePointerCapture","isTouch","dragListeners","onDragChange","onDragEnd","onDragStart","persist","startDrag","genericEventData","_getPointerEventValue","onCancel","vx","_this$state2$velociti","vy","mx","_this$state2$movement","my","ix","_this$state2$_intenti","iy","endState","swipeVelocity","svx","_this$config$swipeVel","svy","swipeDistance","sx","_this$config$swipeDis","sy","filterTaps","prototype","_assertThisInitialized","requestAnimationFrame","_getPointerEventValue2","startState","_this2","DEFAULT_DRAG_DELAY","DEFAULT_RUBBERBAND","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","defaultWindow","defaultCoordinatesOptions","getInternalGenericOptions","_config$eventOptions","passive","_config$eventOptions$","capture","_config$eventOptions$2","_config$eventOptions$3","_config$window","_config$domTarget","_config$enabled","restConfig","_objectWithoutPropertiesLoose","_config","getInternalGestureOptions","gestureConfig","_gestureConfig$thresh","_gestureConfig$rubber","_gestureConfig$enable","_gestureConfig$initia","getInternalCoordinatesOptions","coordinatesConfig","_coordinatesConfig","_coordinatesConfig$bo","internalOptions","boundsArray","left","right","top","bottom","getInternalDistanceAngleOptions","distanceAngleConfig","distanceBounds","_distanceAngleConfig$","angleBounds","_distanceAngleConfig$2","_distanceAngleConfig","getInternalDragOptions","dragConfig","_dragConfig","dragOptions","_dragOptions$swipeVel","_dragOptions$swipeDis","_dragOptions$delay","_dragOptions$filterTa","internalCoordinatesOptions","useDrag","mergedConfig","DistanceAngleRecognizer","d","a","delta_a","newTurns","movement_d","movement_a","PinchRecognizer","_DistanceAngleRecogni","pinchShouldStart","onPinchStart","_getTwoTouchesEventDa","onPinchChange","_getTwoTouchesEventDa2","onPinchEnd","onGestureStart","preventDefault","_getWebkitGestureEven","onGestureChange","_getWebkitGestureEven2","onGestureEnd","updateTouchData","_getTwoTouchesEventDa3","wheelShouldRun","getWheelValuesFromEvent","delta_d","_getWheelEventValues$","prev_d","_this$state$values","prev_a","onWheel","onWheelEnd","onWheelStart","onWheelChange","_this$getWheelValuesF","process","env","NODE_ENV","console","warn","_this$getWheelValuesF2","usePinch","WheelRecognizer","getValuesFromEvent","prevValues","_getWheelEventValues","_this$getValuesFromEv","_this$getValuesFromEv2","useWheel","MoveRecognizer","moveShouldRun","onMove","onMoveEnd","onMoveStart","onMoveChange","onPointerEnter","hover","_getPointerEventValue3","onPointerLeave","_getPointerEventValue4","useMove","useHover","ScrollRecognizer","scrollShouldRun","onScroll","onScrollEnd","onScrollStart","onScrollChange","_getScrollEventValues","_getScrollEventValues2","useScroll","useGesture","useState","Set","k","replace","actions","_React$useState","internalHandlers","_nativeHandlers","has","includeStartEndHandlers","onHover","handlerKey","startKey","endKey"],"sources":["../src/utils/math.ts","../src/utils/utils.ts","../src/utils/state.ts","../src/utils/event.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/Recognizer.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/utils/config.ts","../src/hooks/useDrag.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/hooks/usePinch.ts","../src/recognizers/WheelRecognizer.ts","../src/hooks/useWheel.ts","../src/recognizers/MoveRecognizer.ts","../src/hooks/useMove.ts","../src/hooks/useHover.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useScroll.ts","../src/hooks/useGesture.ts"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n/**\n * Calculates velocity\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @param len the length of the delta vector\n * @returns velocity\n */\nexport function calculateVelocity(delta: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...delta)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(delta: T, delta_t: number): T {\n  return (delta_t ? delta.map(v => v / delta_t) : Array(delta.length).fill(0)) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param delta\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(delta: T, len?: number): T {\n  len = len || Math.hypot(...delta) || 1\n  return delta.map(v => v / len!) as T\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...delta)\n\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len),\n  }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla\n * :https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n\nexport function getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  const abs = Math.abs(movement)\n  return abs >= threshold ? sign(movement) * threshold : false\n}\n\nfunction minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min\n  }\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max\n  }\n  return position\n}\n","import { Fn, Vector2 } from '../types'\n\n// blank function\nexport function noop() {}\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\nexport const def = {\n  array: <T>(value: T | T[]): T[] => (Array.isArray(value) ? value : [value, value]),\n  withDefault: <T>(value: T | undefined, defaultIfUndefined: T): T => (value !== void 0 ? value : defaultIfUndefined),\n}\n\nexport function matchKeysFromObject<T extends object, K extends object>(obj: T, matchingObject: K): Partial<T> {\n  const o: Partial<T> = {}\n  Object.entries(obj).forEach(\n    ([key, value]) => (value !== void 0 || key in matchingObject) && (o[key as keyof T] = value)\n  )\n  return o\n}\n\nexport function valueFn(v: Vector2 | (() => Vector2)) {\n  return typeof v === 'function' ? v() : v\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2 } from '../types'\n\nexport function getInitialState(): State {\n  // common initial state for all gestures\n  const initialCommon: CommonGestureState = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n  }\n\n  // initial state for coordinates-based gestures\n  const initialCoordinates: Coordinates = {\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  }\n\n  // initial state for distance and angle-based gestures (pinch)\n  const initialDistanceAngle: DistanceAngle = {\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    origin: undefined,\n    turns: 0,\n  }\n\n  // initial state object (used by the gesture controller)\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false,\n    },\n    drag: {\n      ...initialCommon,\n      ...initialCoordinates,\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0],\n    },\n    pinch: { ...initialCommon, ...initialDistanceAngle },\n    wheel: { ...initialCommon, ...initialCoordinates },\n    move: { ...initialCommon, ...initialCoordinates },\n    scroll: { ...initialCommon, ...initialCoordinates },\n  }\n}\n","import { Fn, EventOptions, UseGestureEvent, Vector2, WebKitGestureEvent } from '../types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nexport const supportsTouchEvents = () => isBrowser && window.ontouchstart === null\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([eventName, fn]) => el[action](eventName, fn, options))\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: UseGestureEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\n\nfunction getTouchEvents(event: UseGestureEvent) {\n  if ('touches' in event) {\n    const { touches, changedTouches } = event\n    return touches.length > 0 ? touches : changedTouches\n  }\n  return null\n}\n\nexport function getGenericEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const touchEvents = getTouchEvents(event)\n  const touches = (touchEvents && touchEvents.length) || 0\n  const down = touches > 0 || buttons > 0\n  return { touches, down, buttons, ...getModifierKeys(event) }\n}\n\ntype Values = { values: Vector2 }\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: UseGestureEvent): Values {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return { values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0] }\n}\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: UseGestureEvent<React.WheelEvent>): Values {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { values: [deltaX, deltaY] }\n}\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): Values {\n  const touchEvents = getTouchEvents(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return { values: [clientX, clientY] }\n}\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent): Values {\n  return { values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation] as Vector2 }\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent) {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const values: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { values, origin }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n} from './types'\nimport { getInitialState } from './utils/state'\nimport { addListeners, removeListeners } from './utils/event'\nimport { chainFns } from './utils/utils'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] }>\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n *\n * @template BinderType the type the bind function should return\n */\nexport default class Controller {\n  public config!: InternalConfig\n  public handlers!: Partial<InternalHandlers>\n  public state: State = getInitialState() // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    this.resetBindings()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(stateKey as StateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render).\n   * Resets the binding object and remove dom listeners attached to config.domTarget\n   */\n  public resetBindings = (): void => {\n    this.bindings = {}\n    const domTarget = this.getDomTarget()\n    if (domTarget) {\n      removeListeners(domTarget, this.domListeners, this.config.eventOptions)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Returns the domTarget element and parses a ref if needed.\n   */\n  private getDomTarget = (): EventTarget | null | undefined => {\n    const { domTarget } = this.config\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window.\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.eventOptions)\n  }\n\n  /**\n   * Commodity function to let recognizers simply remove listeners to config.window.\n   */\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.eventOptions)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  public addDomTargetListeners = (target: EventTarget): void => {\n    /** We iterate on the entries of this.binding for each event, then we chain\n     * the array of functions mapped to it and push them to this.domListeners\n     */\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(fns as Fn[]))])\n    })\n\n    addListeners(target, this.domListeners, this.config.eventOptions)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  public addBindings = (eventNames: ReactEventHandlerKey | ReactEventHandlerKey[], fn: Fn): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n    eventNamesArray.forEach(eventName => {\n      if (this.bindings[eventName]) this.bindings[eventName]!.push(fn)\n      else this.bindings[eventName] = [fn]\n    })\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with.\n   */\n  public getBindings = (): ReactEventHandlers => {\n    const bindings: ReactEventHandlers = {}\n    const { captureString } = this.config\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      bindings[key] = chainFns(...(fnsArray as Fn[]))\n    })\n\n    return bindings\n  }\n\n  public getBind = () => {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (this.config.domTarget) {\n      const domTarget = this.getDomTarget()\n      domTarget && this.addDomTargetListeners(domTarget)\n      return this.clean\n    }\n\n    // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n    return this.getBindings()\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  RecognizerClasses,\n  GenericOptions,\n  NativeHandlersPartial,\n  ReactEventHandlerKey,\n  Fn,\n} from '../types'\n/**\n * @private\n *\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param {Partial<InternalHandlers>} handlers\n * @param {RecognizerClasses} classes\n * @param {InternalConfig} config\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  classes: RecognizerClasses,\n  config: InternalConfig,\n  nativeHandlers?: NativeHandlersPartial\n): (...args: any[]) => HookReturnType<Config> {\n  // The gesture controller keeping track of all gesture states\n  const controller = React.useMemo(() => {\n    const current = new Controller()\n\n    /**\n     * The bind function will create gesture recognizers and return the right\n     * bind object depending on whether `domTarget` was specified in the config object.\n     */\n    const bind = (...args: any[]) => {\n      current.resetBindings()\n      for (let RecognizerClass of classes) {\n        new RecognizerClass(current, args).addBindings()\n      }\n\n      // we also add event bindings for native handlers\n      if (controller.nativeRefs) {\n        for (let eventName in controller.nativeRefs)\n          current.addBindings(\n            eventName as ReactEventHandlerKey,\n            // @ts-ignore we're cheating when it comes to event type :(\n            controller.nativeRefs[eventName] as Fn\n          )\n      }\n\n      return current.getBind() as HookReturnType<Config>\n    }\n\n    return { nativeRefs: nativeHandlers, current, bind }\n  }, [])\n\n  // We reassign the config and handlers to the controller on every render.\n  controller.current!.config = config\n  controller.current!.handlers = handlers\n  // We assign nativeHandlers, otherwise they won't be refreshed on the next render.\n  controller.nativeRefs = nativeHandlers\n\n  // Run controller clean functions on unmount.\n  React.useEffect(() => controller.current!.clean, [])\n\n  return controller.bind\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  Fn,\n  UseGestureEvent,\n  IngKey,\n  InternalConfig,\n  GestureState,\n  PartialGestureState,\n  Vector2,\n  FalseOrNumber,\n  FullGestureState,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { subV, addV, getIntentionalDisplacement, rubberbandIfOutOfBounds } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\n/**\n * @private\n * Recognizer abstract class.\n *\n * @protected\n * @abstract\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<T extends StateKey> {\n  protected abstract ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly stateKey: T,\n    protected readonly controller: Controller,\n    protected readonly args: any[] = []\n  ) {}\n\n  // Returns the gesture config\n  protected get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  protected get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  protected get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  protected get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  // Conveninence method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Conveninence method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // Convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // Convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  /**\n   * Utility function to get kinematics of the gesture.\n   *\n   * @abstract\n   * @values - values we want to calculate the kinematics from\n   * @event - the pointer event\n   * @returns - set of values including movement, velocity, velocities, distance and direction\n   */\n  protected abstract getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T>\n\n  protected abstract mapStateValues(state: GestureState<T>): PartialGestureState<T>\n\n  // Should return the bindings to be added for a given gesture\n  public abstract addBindings(): void\n\n  /**\n   * Returns a generic, common payload for all gestures from an event.\n   *\n   * @param {UseGestureEvent} event\n   * @param {boolean} [isStartEvent]\n   * @returns - the generic gesture payload\n   */\n  protected getGenericPayload(event: UseGestureEvent, isStartEvent?: boolean) {\n    const { timeStamp, type } = event\n    const { values, startTime } = this.state\n\n    return {\n      _lastEventType: type,\n      event,\n      timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime!,\n      args: this.args,\n      previous: values,\n    }\n  }\n  /**\n   * Returns the reinitialized start state for the gesture.\n   * Should be common to all gestures.\n   *\n   * @param {Vector2} values\n   * @param {UseGestureEvent} event\n   * @returns - the start state for the gesture\n   */\n  protected getStartGestureState = (values: Vector2, event: UseGestureEvent) => {\n    return {\n      ...getInitialState()[this.stateKey],\n      _active: true,\n      values,\n      initial: values,\n      offset: this.state.offset,\n      lastOffset: this.state.offset,\n      startTime: event.timeStamp,\n    }\n  }\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    _state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2, state: GestureState<T> = this.state): PartialGestureState<T> {\n    const { initial, threshold, rubberband } = this.config\n\n    const [t0, t1] = threshold\n\n    const { _initial, _active, _intentional: intentional, lastOffset, movement: prevMovement } = state\n    let [i0, i1] = intentional\n\n    const [_m0, _m1] = this.getInternalMovement(values, state)\n\n    /**\n     * For both dimensions of the gesture, check its intentionality on each frame.\n     */\n    if (i0 === false) {\n      i0 = getIntentionalDisplacement(_m0, t0)\n    }\n    if (i1 === false) {\n      i1 = getIntentionalDisplacement(_m1, t1)\n    }\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state)\n\n    const { _intentional, _blocked } = intentionalityCheck\n    const [_i0, _i1] = _intentional!\n    const _movement = [_m0, _m1]\n\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0]\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1]\n\n    /**\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\n     * stop right there.\n     */\n    if (_blocked) return { ...intentionalityCheck, _movement, delta: [0, 0] }\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement = [\n      _i0 !== false ? _m0 - _i0 : valueFn(initial)[0],\n      _i1 !== false ? _m1 - _i1 : valueFn(initial)[1],\n    ] as Vector2\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = this.rubberband(addV(movement, _initial), _rubberband) // rubberbanded movement\n\n    return {\n      ...intentionalityCheck,\n      _initial,\n      _movement,\n      movement,\n      offset: this.rubberband(offset, _rubberband), // rubberbanded offset\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Runs rubberband on a vector\n  protected rubberband = (vector: Vector2, rubberband: Vector2): Vector2 => {\n    const { bounds } = this.config\n\n    /**\n     * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\n     */\n    return vector.map((v, i) => rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i])) as Vector2\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n    this.removeWindowListeners()\n  }\n\n  /**\n   * Fires the gesture handler\n   *\n   * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\n   */\n  protected fireGestureHandler = (forceFlag?: boolean): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't do fire the handler.\n    const [intentionalX, intentionalY] = this.state._intentional\n    if (!forceFlag && intentionalX === false && intentionalY === false) return null\n\n    const { _active, active } = this.state\n\n    this.state.active = _active\n    this.state.first = _active && !active // `first` is true when the gesture becomes active\n    this.state.last = active && !_active // `last` is true when the gesture becomes inactive\n\n    this.controller.state.shared[this.ingKey] = _active // Sets dragging, pinching, etc. to the gesture active state\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n    } as FullGestureState<T>\n\n    // @ts-ignore\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    // Cleans the gesture when the gesture is no longer active.\n    if (!_active) this.clean()\n\n    return state\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, FalseOrNumber, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n * @abstract\n * @class CoordinatesRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   *\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\n   * @param {Vector2} _movement\n   * @param {PartialGestureState<T>} state\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    let [_ix, _iy] = _intentional\n    const intentionalMovement = _ix !== false || _iy !== false\n    let { axis } = state\n    let _blocked = false\n\n    // If the movement is intentional, we can compute axis.\n    if (intentionalMovement) {\n      const [absX, absY] = _movement.map(Math.abs)\n\n      const { axis: configAxis, lockDirection } = this.config\n\n      // We make sure we only set axis value if it hadn't been detected before.\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true\n          else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            const lockedIndex = axis === 'x' ? 1 : 0\n            _intentional![lockedIndex] = false\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false]\n        }\n      }\n    }\n\n    return { _intentional, _blocked, axis } as PartialGestureState<T>\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { _blocked, delta, movement } = movementDetection\n\n    if (_blocked) return movementDetection\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { xy: state.values, vxvy: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, Fn, IngKey } from '../types'\nimport { noop } from '../utils/utils'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { calculateDistance, sign } from '../utils/math'\n\nconst TAP_DISTANCE_THRESHOLD = 3\nconst SWIPE_MAX_ELAPSED_TIME = 220\nconst FILTER_REPEATED_EVENTS_DELAY = 200\n\nexport default class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  ingKey = 'dragging' as IngKey\n  wasTouch = false\n\n  constructor(controller: Controller, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  private isEventTypeTouch = (type?: string) => !!type && type.indexOf('touch') === 0\n\n  private dragShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    const { _lastEventType } = this.state\n    /**\n     * This tries to filter out mouse events triggered by touch screens\n     * */\n    // If the previous gesture was touch-based, and the current one is mouse based,\n    // this means that we might be dealing with mouse simulated events if they're close to\n    // each other. We're only doing this check when we're not using pointer events.\n    if (\n      !this.controller.config.pointer &&\n      this.isEventTypeTouch(_lastEventType) &&\n      !this.isEventTypeTouch(event.type)\n    ) {\n      const delay = Math.abs(event.timeStamp - this.state.startTime)\n      if (delay < FILTER_REPEATED_EVENTS_DELAY) return false\n    }\n\n    return this.enabled && touches < 2\n  }\n\n  private setPointers = (event: UseGestureEvent<PointerEvent>) => {\n    const { currentTarget, pointerId } = event\n    if (currentTarget) currentTarget.setPointerCapture(pointerId)\n    this.updateGestureState({ currentTarget, pointerId })\n  }\n\n  private removePointers = () => {\n    const { currentTarget, pointerId } = this.state\n    if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\n  }\n\n  private setListeners = (isTouch: boolean) => {\n    this.removeWindowListeners()\n    const dragListeners: [string, Fn][] = isTouch\n      ? [\n          ['touchmove', this.onDragChange],\n          ['touchend', this.onDragEnd],\n          ['touchcancel', this.onDragEnd],\n        ]\n      : [\n          ['mousemove', this.onDragChange],\n          ['mouseup', this.onDragEnd],\n        ]\n    this.addWindowListeners(dragListeners)\n  }\n\n  onDragStart = (event: UseGestureEvent): void => {\n    if (!this.dragShouldStart(event)) return\n    // if pointers events\n    if (this.controller.config.pointer) this.setPointers(event as PointerEvent)\n    else this.setListeners(this.isEventTypeTouch(event.type))\n\n    if (this.config.delay > 0) {\n      this.state._delayedEvent = true\n      if (typeof event.persist === 'function') event.persist()\n      this.setTimeout(() => this.startDrag(event), this.config.delay)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag(event: UseGestureEvent) {\n    const { values } = getPointerEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: UseGestureEvent): void => {\n    const { canceled } = this.state\n    if (canceled) return\n\n    if (!this.state._active) {\n      if (this.state._delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    if (!genericEventData.down) {\n      this.onDragEnd(event)\n      return\n    }\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    let { _isTap } = this.state\n    if (_isTap && calculateDistance(kinematics._movement!) >= TAP_DISTANCE_THRESHOLD) _isTap = false\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      _isTap,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: UseGestureEvent): void => {\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n\n    const {\n      _isTap,\n      values,\n      velocities: [vx, vy],\n      movement: [mx, my],\n      _intentional: [ix, iy],\n    } = this.state\n\n    const endState = {\n      ...this.getGenericPayload(event),\n      ...this.getMovement(values),\n    }\n\n    const { elapsedTime } = endState\n\n    const {\n      swipeVelocity: [svx, svy],\n      swipeDistance: [sx, sy],\n    } = this.config\n\n    const swipe: [number, number] = [0, 0]\n\n    if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateGestureState({\n      event,\n      ...endState,\n      tap: _isTap,\n      swipe,\n    })\n    this.fireGestureHandler(this.config.filterTaps && this.state._isTap)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._delayedEvent = false\n\n    if (this.controller.config.pointer) this.removePointers()\n  }\n\n  onCancel = (): void => {\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart)\n      this.controller.addBindings('onPointerMove', this.onDragChange)\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd)\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart)\n    }\n  }\n}\n","import { def, matchKeysFromObject } from './utils'\nimport {\n  Vector2,\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  Tuple,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  CoordinatesOptions,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n} from '../types'\n\nconst DEFAULT_DRAG_DELAY = 180\nconst DEFAULT_RUBBERBAND = 0.15\nconst DEFAULT_SWIPE_VELOCITY = 0.5\nconst DEFAULT_SWIPE_DISTANCE = 60\n\nconst defaultWindow = typeof window !== 'undefined' ? window : undefined\n\nconst defaultCoordinatesOptions: CoordinatesOptions = {\n  lockDirection: false,\n  axis: undefined,\n  bounds: undefined,\n}\n\n/**\n * @private\n *\n * Returns the internal generic option object.\n *\n * @param {Partial<GenericOptions>} [config={}]\n * @returns {InternalGenericOptions}\n */\nexport function getInternalGenericOptions(config: Partial<GenericOptions> = {}): InternalGenericOptions {\n  let {\n    eventOptions: { passive = true, capture = false, pointer = false } = {},\n    window = defaultWindow,\n    domTarget = undefined,\n    enabled = true,\n    ...restConfig\n  } = config\n\n  return {\n    ...restConfig,\n    enabled,\n    domTarget,\n    window,\n    // passive is always true if there's no domTarget\n    eventOptions: { passive: !domTarget || !!passive, capture: !!capture },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer,\n  }\n}\n\nexport function getInternalGestureOptions(gestureConfig: Partial<GestureOptions>): InternalGestureOptions {\n  let { threshold = undefined, rubberband = 0, enabled = true, initial = [0, 0] } = gestureConfig\n\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0\n  if (threshold === void 0) threshold = 0\n\n  return {\n    enabled,\n    initial,\n    threshold: def.array(threshold) as Vector2,\n    rubberband: def.array(rubberband) as Vector2,\n  }\n}\n\nexport function getInternalCoordinatesOptions(coordinatesConfig: CoordinatesConfig = {}): InternalCoordinatesOptions {\n  const { axis, lockDirection, bounds = {}, ...internalOptions } = coordinatesConfig\n\n  const boundsArray = [\n    [def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)],\n    [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    ...defaultCoordinatesOptions,\n    ...matchKeysFromObject({ axis, lockDirection }, coordinatesConfig),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDistanceAngleOptions(\n  distanceAngleConfig: DistanceAngleConfig = {}\n): InternalDistanceAngleOptions {\n  const { distanceBounds = {}, angleBounds = {}, ...internalOptions } = distanceAngleConfig\n\n  const boundsArray = [\n    [def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)],\n    [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDragOptions(dragConfig: DragConfig = {}): InternalDragOptions {\n  let { enabled, threshold, bounds, rubberband, initial, ...dragOptions } = dragConfig\n  let {\n    swipeVelocity = DEFAULT_SWIPE_VELOCITY,\n    swipeDistance = DEFAULT_SWIPE_DISTANCE,\n    delay = false,\n    filterTaps = false,\n    axis,\n    lockDirection,\n  } = dragOptions\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0)\n  } else {\n    filterTaps = true\n  }\n\n  const internalCoordinatesOptions = getInternalCoordinatesOptions(\n    matchKeysFromObject({ enabled, threshold, bounds, rubberband, axis, lockDirection, initial }, dragConfig)\n  )\n\n  return {\n    ...internalCoordinatesOptions,\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity) as Vector2,\n    swipeDistance: def.array(swipeDistance) as Vector2,\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0,\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseDragConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDragOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Drag hook.\n *\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useDrag<Config extends UseDragConfig>(\n  handler: Handler<'drag'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...drag } = config as UseDragConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    drag: getInternalDragOptions(drag),\n  }\n\n  return useRecognizers<Config>({ drag: handler }, [DragRecognizer], mergedConfig)\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n * @abstract\n * @class DistanceAngleRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement([d, a]: [number, number?], state: GestureState<T>): Vector2 {\n    const { values: da, turns, initial } = state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a !== void 0 ? a : da[1]\n\n    let delta_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(delta_a) > 270 ? turns + sign(delta_a) : turns\n\n    // we update the angle difference to its corrected value\n\n    const movement_d = d - initial[0]\n    const movement_a = a - 360 * newTurns - initial[1]\n    return [movement_d, movement_a]\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp, initial } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { delta, movement } = movementDetection\n\n    const turns = (values[1] - movement![1] - initial[1]) / 360\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      turns,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { da: state.values, vdva: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { TouchEvent, WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey, Vector2, WebKitGestureEvent } from '../types'\nimport { noop } from '../utils/utils'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventData,\n  getWheelEventValues,\n  supportsGestureEvents,\n  getWebkitGestureEventValues,\n} from '../utils/event'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  ingKey = 'pinching' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  private pinchShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches === 2\n  }\n\n  onPinchStart = (event: UseGestureEvent<TouchEvent>) => {\n    if (!this.pinchShouldStart(event)) return\n\n    const { values, origin } = getTwoTouchesEventData(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: UseGestureEvent<TouchEvent>): void => {\n    const { canceled, timeStamp, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n    if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventData(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: UseGestureEvent): void => {\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    this.state._active = false\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.updateSharedState({ down: false, touches: 0 })\n\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const { values } = getWebkitGestureEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getWebkitGestureEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    event.preventDefault()\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  updateTouchData = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2 || !this.state._active) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.state.origin = origin\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const {\n      values: [, delta_d],\n    } = getWheelEventValues(event)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (!this.controller.config.eventOptions.passive) {\n      event.preventDefault()\n    } else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart)\n      this.controller.addBindings('onGestureChange', this.onGestureChange)\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd)\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData)\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart)\n      this.controller.addBindings('onTouchMove', this.onPinchChange)\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd)\n\n      this.controller.addBindings('onWheel', this.onWheel)\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UsePinchConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDistanceAngleOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Pinch hook.\n *\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function usePinch<Config extends UsePinchConfig>(\n  handler: Handler<'pinch'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...pinch } = config as UsePinchConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    pinch: getInternalDistanceAngleOptions(pinch),\n  }\n\n  return useRecognizers<Config>({ pinch: handler }, [PinchRecognizer], mergedConfig)\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  ingKey = 'wheeling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return false\n    return this.enabled\n  }\n\n  private getValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const { values: prevValues } = this.state\n    const { values } = getWheelEventValues(event)\n    return { values: addV(values, prevValues) }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values } = this.getValuesFromEvent(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = this.getValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onWheel', this.onWheel)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseWheelConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Wheel hook.\n *\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useWheel<Config extends UseWheelConfig>(\n  handler: Handler<'wheel'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...wheel } = config as UseWheelConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    wheel: getInternalCoordinatesOptions(wheel),\n  }\n\n  return useRecognizers<Config>({ wheel: handler }, [WheelRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  ingKey = 'moving' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('move', controller, args)\n  }\n\n  private moveShouldRun = () => {\n    return this.enabled\n  }\n\n  onMove = (event: UseGestureEvent): void => {\n    if (!this.moveShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: UseGestureEvent): void => {\n    const { values } = getPointerEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.state._active = false\n\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  onPointerEnter = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event, true),\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event),\n        values,\n        active: false,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter)\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave)\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter)\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave)\n      }\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseMoveConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Move hook.\n *\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useMove<Config extends UseMoveConfig>(\n  handler: Handler<'move'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...move } = config as UseMoveConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    move: getInternalCoordinatesOptions(move),\n  }\n\n  return useRecognizers<Config>({ move: handler }, [MoveRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseHoverConfig } from '../types'\nimport { getInternalGenericOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Hover hook.\n *\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useHover<Config extends UseHoverConfig>(\n  handler: Handler<'hover'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...hover } = config as UseHoverConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    hover: { enabled: true, ...hover },\n  }\n\n  return useRecognizers<Config>({ hover: handler }, [MoveRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  ingKey = 'scrolling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  private scrollShouldRun = () => {\n    return this.enabled\n  }\n\n  onScroll = (event: UseGestureEvent): void => {\n    if (!this.scrollShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onScrollEnd)\n\n    if (!this.state._active) this.onScrollStart(event)\n    else this.onScrollChange(event)\n  }\n\n  onScrollStart = (event: UseGestureEvent): void => {\n    const { values } = getScrollEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getScrollEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onScroll', this.onScroll)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseScrollConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Scroll hook.\n *\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useScroll<Config extends UseScrollConfig>(\n  handler: Handler<'scroll'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...scroll } = config as UseScrollConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    scroll: getInternalCoordinatesOptions(scroll),\n  }\n\n  return useRecognizers<Config>({ scroll: handler }, [ScrollRecognizer], mergedConfig)\n}\n","import React from 'react'\nimport useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport {\n  getInternalGenericOptions,\n  getInternalDragOptions,\n  getInternalCoordinatesOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\nimport {\n  InternalConfig,\n  HandlerKey,\n  UserHandlersPartial,\n  InternalHandlers,\n  UserHandlers,\n  RecognizerClasses,\n  UseGestureConfig,\n  HookReturnType,\n} from '../types'\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<Config extends UseGestureConfig>(\n  handlers: UserHandlersPartial,\n  config: UseGestureConfig = {}\n): (...args: any[]) => HookReturnType<Config> {\n  /**\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n   * actions will include 'onDrag' and 'onMove.\n   */\n  const [actions] = React.useState(() => new Set(Object.keys(handlers).map(k => k.replace(/End|Start/, ''))))\n\n  /**\n   * Here we compute the derived internal config based on the provided config object.\n   * We decompose the config into its generic and gesture options and compute each.\n   * TODO: this is currently done on every render!\n   */\n  const { drag, wheel, move, scroll, pinch, hover, ...restConfig } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions(restConfig)\n\n  const classes: RecognizerClasses = []\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  // will hold reference to native handlers such as onClick, onMouseDown, etc.\n  const _nativeHandlers = { ...handlers }\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer)\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers)\n    mergedConfig.drag = getInternalDragOptions(drag)\n  }\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer)\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers)\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  }\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer)\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers)\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  }\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer)\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers)\n    mergedConfig.move = getInternalCoordinatesOptions(move)\n  }\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer)\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers)\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  }\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer)\n    internalHandlers.hover = handlers.onHover\n    mergedConfig.hover = { enabled: true, ...hover }\n    delete _nativeHandlers.onHover\n  }\n\n  return useRecognizers<Config>(internalHandlers, classes, mergedConfig, _nativeHandlers)\n}\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\nfunction includeStartEndHandlers(\n  handlers: UserHandlersPartial,\n  handlerKey: HandlerKey,\n  _nativeHandlers: UserHandlersPartial\n) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  delete _nativeHandlers[handlerKey]\n  delete _nativeHandlers[startKey]\n  delete _nativeHandlers[endKey]\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}